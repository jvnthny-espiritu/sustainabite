{
  "version": 3,
  "sources": ["../../@ionic/core/components/index6.js", "../../@ionic/core/components/index8.js"],
  "sourcesContent": ["/*!\r\n * (C) Ionic http://ionicframework.com - MIT License\r\n */\r\n/**\r\n * Logs a warning to the console with an Ionic prefix\r\n * to indicate the library that is warning the developer.\r\n *\r\n * @param message - The string message to be logged to the console.\r\n */\r\nconst printIonWarning = (message, ...params) => {\r\n  return console.warn(`[Ionic Warning]: ${message}`, ...params);\r\n};\r\n/*\r\n * Logs an error to the console with an Ionic prefix\r\n * to indicate the library that is warning the developer.\r\n *\r\n * @param message - The string message to be logged to the console.\r\n * @param params - Additional arguments to supply to the console.error.\r\n */\r\nconst printIonError = (message, ...params) => {\r\n  return console.error(`[Ionic Error]: ${message}`, ...params);\r\n};\r\n/**\r\n * Prints an error informing developers that an implementation requires an element to be used\r\n * within a specific selector.\r\n *\r\n * @param el The web component element this is requiring the element.\r\n * @param targetSelectors The selector or selectors that were not found.\r\n */\r\nconst printRequiredElementError = (el, ...targetSelectors) => {\r\n  return console.error(`<${el.tagName.toLowerCase()}> must be used inside ${targetSelectors.join(' or ')}.`);\r\n};\r\n\r\nexport { printIonError as a, printRequiredElementError as b, printIonWarning as p };\r\n", "/*!\r\n * (C) Ionic http://ionicframework.com - MIT License\r\n */\r\nimport { c as componentOnReady } from './helpers.js';\r\nimport { b as printRequiredElementError } from './index6.js';\r\n\r\nconst ION_CONTENT_TAG_NAME = 'ION-CONTENT';\r\nconst ION_CONTENT_ELEMENT_SELECTOR = 'ion-content';\r\nconst ION_CONTENT_CLASS_SELECTOR = '.ion-content-scroll-host';\r\n/**\r\n * Selector used for implementations reliant on `<ion-content>` for scroll event changes.\r\n *\r\n * Developers should use the `.ion-content-scroll-host` selector to target the element emitting\r\n * scroll events. With virtual scroll implementations this will be the host element for\r\n * the scroll viewport.\r\n */\r\nconst ION_CONTENT_SELECTOR = `${ION_CONTENT_ELEMENT_SELECTOR}, ${ION_CONTENT_CLASS_SELECTOR}`;\r\nconst isIonContent = (el) => el.tagName === ION_CONTENT_TAG_NAME;\r\n/**\r\n * Waits for the element host fully initialize before\r\n * returning the inner scroll element.\r\n *\r\n * For `ion-content` the scroll target will be the result\r\n * of the `getScrollElement` function.\r\n *\r\n * For custom implementations it will be the element host\r\n * or a selector within the host, if supplied through `scrollTarget`.\r\n */\r\nconst getScrollElement = async (el) => {\r\n  if (isIonContent(el)) {\r\n    await new Promise((resolve) => componentOnReady(el, resolve));\r\n    return el.getScrollElement();\r\n  }\r\n  return el;\r\n};\r\n/**\r\n * Queries the element matching the selector for IonContent.\r\n * See ION_CONTENT_SELECTOR for the selector used.\r\n */\r\nconst findIonContent = (el) => {\r\n  /**\r\n   * First we try to query the custom scroll host selector in cases where\r\n   * the implementation is using an outer `ion-content` with an inner custom\r\n   * scroll container.\r\n   */\r\n  const customContentHost = el.querySelector(ION_CONTENT_CLASS_SELECTOR);\r\n  if (customContentHost) {\r\n    return customContentHost;\r\n  }\r\n  return el.querySelector(ION_CONTENT_SELECTOR);\r\n};\r\n/**\r\n * Queries the closest element matching the selector for IonContent.\r\n */\r\nconst findClosestIonContent = (el) => {\r\n  return el.closest(ION_CONTENT_SELECTOR);\r\n};\r\n/**\r\n * Scrolls to the top of the element. If an `ion-content` is found, it will scroll\r\n * using the public API `scrollToTop` with a duration.\r\n */\r\nconst scrollToTop = (el, durationMs) => {\r\n  if (isIonContent(el)) {\r\n    const content = el;\r\n    return content.scrollToTop(durationMs);\r\n  }\r\n  return Promise.resolve(el.scrollTo({\r\n    top: 0,\r\n    left: 0,\r\n    behavior: durationMs > 0 ? 'smooth' : 'auto',\r\n  }));\r\n};\r\n/**\r\n * Scrolls by a specified X/Y distance in the component. If an `ion-content` is found, it will scroll\r\n * using the public API `scrollByPoint` with a duration.\r\n */\r\nconst scrollByPoint = (el, x, y, durationMs) => {\r\n  if (isIonContent(el)) {\r\n    const content = el;\r\n    return content.scrollByPoint(x, y, durationMs);\r\n  }\r\n  return Promise.resolve(el.scrollBy({\r\n    top: y,\r\n    left: x,\r\n    behavior: durationMs > 0 ? 'smooth' : 'auto',\r\n  }));\r\n};\r\n/**\r\n * Prints an error informing developers that an implementation requires an element to be used\r\n * within either the `ion-content` selector or the `.ion-content-scroll-host` class.\r\n */\r\nconst printIonContentErrorMsg = (el) => {\r\n  return printRequiredElementError(el, ION_CONTENT_ELEMENT_SELECTOR);\r\n};\r\n/**\r\n * Several components in Ionic need to prevent scrolling\r\n * during a gesture (card modal, range, item sliding, etc).\r\n * Use this utility to account for ion-content and custom content hosts.\r\n */\r\nconst disableContentScrollY = (contentEl) => {\r\n  if (isIonContent(contentEl)) {\r\n    const ionContent = contentEl;\r\n    const initialScrollY = ionContent.scrollY;\r\n    ionContent.scrollY = false;\r\n    /**\r\n     * This should be passed into resetContentScrollY\r\n     * so that we can revert ion-content's scrollY to the\r\n     * correct state. For example, if scrollY = false\r\n     * initially, we do not want to enable scrolling\r\n     * when we call resetContentScrollY.\r\n     */\r\n    return initialScrollY;\r\n  }\r\n  else {\r\n    contentEl.style.setProperty('overflow', 'hidden');\r\n    return true;\r\n  }\r\n};\r\nconst resetContentScrollY = (contentEl, initialScrollY) => {\r\n  if (isIonContent(contentEl)) {\r\n    contentEl.scrollY = initialScrollY;\r\n  }\r\n  else {\r\n    contentEl.style.removeProperty('overflow');\r\n  }\r\n};\r\n\r\nexport { ION_CONTENT_CLASS_SELECTOR as I, findClosestIonContent as a, ION_CONTENT_ELEMENT_SELECTOR as b, scrollByPoint as c, disableContentScrollY as d, findIonContent as f, getScrollElement as g, isIonContent as i, printIonContentErrorMsg as p, resetContentScrollY as r, scrollToTop as s };\r\n"],
  "mappings": ";;;;;AASA,IAAM,kBAAkB,CAAC,YAAY,WAAW;AAC9C,SAAO,QAAQ,KAAK,oBAAoB,OAAO,IAAI,GAAG,MAAM;AAC9D;AAQA,IAAM,gBAAgB,CAAC,YAAY,WAAW;AAC5C,SAAO,QAAQ,MAAM,kBAAkB,OAAO,IAAI,GAAG,MAAM;AAC7D;AAQA,IAAM,4BAA4B,CAAC,OAAO,oBAAoB;AAC5D,SAAO,QAAQ,MAAM,IAAI,GAAG,QAAQ,YAAY,CAAC,yBAAyB,gBAAgB,KAAK,MAAM,CAAC,GAAG;AAC3G;;;ACzBA,IAAM,uBAAuB;AAC7B,IAAM,+BAA+B;AACrC,IAAM,6BAA6B;AAQnC,IAAM,uBAAuB,GAAG,4BAA4B,KAAK,0BAA0B;AAC3F,IAAM,eAAe,CAAC,OAAO,GAAG,YAAY;AAW5C,IAAM,mBAAmB,OAAO,OAAO;AACrC,MAAI,aAAa,EAAE,GAAG;AACpB,UAAM,IAAI,QAAQ,CAAC,YAAY,iBAAiB,IAAI,OAAO,CAAC;AAC5D,WAAO,GAAG,iBAAiB;AAAA,EAC7B;AACA,SAAO;AACT;AAKA,IAAM,iBAAiB,CAAC,OAAO;AAM7B,QAAM,oBAAoB,GAAG,cAAc,0BAA0B;AACrE,MAAI,mBAAmB;AACrB,WAAO;AAAA,EACT;AACA,SAAO,GAAG,cAAc,oBAAoB;AAC9C;AAIA,IAAM,wBAAwB,CAAC,OAAO;AACpC,SAAO,GAAG,QAAQ,oBAAoB;AACxC;AAKA,IAAM,cAAc,CAAC,IAAI,eAAe;AACtC,MAAI,aAAa,EAAE,GAAG;AACpB,UAAM,UAAU;AAChB,WAAO,QAAQ,YAAY,UAAU;AAAA,EACvC;AACA,SAAO,QAAQ,QAAQ,GAAG,SAAS;AAAA,IACjC,KAAK;AAAA,IACL,MAAM;AAAA,IACN,UAAU,aAAa,IAAI,WAAW;AAAA,EACxC,CAAC,CAAC;AACJ;AAKA,IAAM,gBAAgB,CAAC,IAAI,GAAG,GAAG,eAAe;AAC9C,MAAI,aAAa,EAAE,GAAG;AACpB,UAAM,UAAU;AAChB,WAAO,QAAQ,cAAc,GAAG,GAAG,UAAU;AAAA,EAC/C;AACA,SAAO,QAAQ,QAAQ,GAAG,SAAS;AAAA,IACjC,KAAK;AAAA,IACL,MAAM;AAAA,IACN,UAAU,aAAa,IAAI,WAAW;AAAA,EACxC,CAAC,CAAC;AACJ;AAKA,IAAM,0BAA0B,CAAC,OAAO;AACtC,SAAO,0BAA0B,IAAI,4BAA4B;AACnE;AAMA,IAAM,wBAAwB,CAAC,cAAc;AAC3C,MAAI,aAAa,SAAS,GAAG;AAC3B,UAAM,aAAa;AACnB,UAAM,iBAAiB,WAAW;AAClC,eAAW,UAAU;AAQrB,WAAO;AAAA,EACT,OACK;AACH,cAAU,MAAM,YAAY,YAAY,QAAQ;AAChD,WAAO;AAAA,EACT;AACF;AACA,IAAM,sBAAsB,CAAC,WAAW,mBAAmB;AACzD,MAAI,aAAa,SAAS,GAAG;AAC3B,cAAU,UAAU;AAAA,EACtB,OACK;AACH,cAAU,MAAM,eAAe,UAAU;AAAA,EAC3C;AACF;",
  "names": []
}
